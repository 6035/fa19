# Phase 3 -- Code Generation

__DUE: Wed Oct 30 23:59:59 EDT 2019__

Code Generation involves producing correct x86-64 assembler code for all Decaf programs. The two following projects will involve code optimizations. For now, we are not interested in whether your generated code is efficient. In fact, make it very inefficient.

By the end of code generation, you should have a fully working Decaf compiler. You'll be able to write, compile, and execute real programs on a real machine!

## Table of Contents

1. [Phase 3 -- Code Generation](#phase-3--code-generation)
    1. [Table of Contents](#table-of-contents)
    1. [Setup](#setup)
    1. [Submission](#submission)
    1. [Project Assignment](#project-assignment)
    1. [Compiling and Libraries](#compiling-and-libraries)
    1. [What to Hand In](#what-to-hand-in)
        1. [Documentation](#documentation)
    1. [Reference](#reference)
    1. [Assembly Examples](#assembly-examples)

## Setup

Run this from your team's repo.

```bash
git pull tests master
```

## Submission

1. create a branch in your team repo, and name it `phase3-submission`
1. commit/push to this branch as many times as you want before/after the deadline
1. we will grade the __MOST RECENT__ commit made to this branch, that was made __BEFORE__ the deadline
    - so if the deadline is 5pm, and you make commits at 3pm, 4pm and 6pm, we will grade the 4pm one

## Project Assignment

For Code Generation, your compiler will translate your high-level IR into a low-level IR. Your low-level IR will include structures that more closely match the machine instructions of a modern architecture. Your compiler will then translate your low-level IR into x86-64 assembly code to be run on Athena. You should target the subset of the x86-64 ISA defined in the [x86-64 architecture guide](#reference), in the reference section at the bottom of this handout.

Your generated code must include all runtime checks listed in the Decaf language specification. Additional checks such as integer overflow are not required.

The two final assignments, _Dataflow Analysis_ and _Optimization_, will focus on improving the efficiency of the target code generated by your compiler. For this assignment, you are not expected to produce great code. In fact, even horrendous code is acceptable. When considering tradeoffs, always choose simplicity of implementation over performance.

You are not constrained as to how you go about generating your final assembly code listing. However, we suggest that you follow the general approach presented in lecture.

You will have a number of opportunities to do some creative design work for the code optimization projects. For this assignment, you should focus your creative energies on designing your Control Flow Graph, familiarizing yourself with our target ISA, your machine-code representations of the run-time structures, and generating correct assembly code. Do not try to produce an improved register allocation scheme; you will be addressing these issues later.

## Compiling and Libraries


```bash
./run.sh --target=assembly 'main.dcf'              # print assembly to stdout
./run.sh --target=assembly 'main.dcf' -o 'main.s'  # write to 'main.s' instead

gcc -no-pie 'main.s' -o 'main'  # create an executable 'main' from 'main.s'

./main                        # run the executable
./main &> /dev/null; echo $?  # print the exit code
```

Decaf does not have any input/output functions. Part of the assignment is to implement the standard x86-64 calling convention for `import` statements, so that you can interface with the outside world. Any function that is called using `import` needs to be linked in separately. `gcc` will link against any standard libraries, such as `printf` (you may need to use the `-l` argument for `gcc` to link some libraries). The testing files provided to you link against the standard C library. If you want to use functions that are not easy to use in Decaf (handle pointers, etc), you are welcome to write your own library calls in `C`, compile them to object files (using `gcc -c`) and then link them in by hand when compiling your assembly.

## What to Hand In

Follow the directions given in project overview handout when writing up your project (repeated at the bottom of this handout). Reminder, the documentation will count towards 20% of your grade. Submitted repositories should have the following structure:
```txt
<GROUPNAME>
├── build.sh
├── run.sh
├── docs/
│   └── phase3.pdf  // write-up for this project, described in project overview handout
├── src/
│   └── ...
├── tests/
│   └── ...
└── ...
```

You should be able to run your compiler from the command line with:
```
./run.sh --target=assembly <FILENAME>
```
Your compiler should then write a x86-64 assembly listing to standard out or the output file specified by `-o`.

Nothing should be written to standard error for a syntactically and semantically correct program (or to standard out, if an output file is specified) unless the `--debug` flag is present. If the `--debug` flag is present, your compiler should still run and produce the same resulting assembly listing. Any debugging output is left to your own discretion. All errors should be written to standard error.

We will run your compilers on the test cases in the tests repository. We strongly recommend you write additional tests of your own, because the provided tests are nowhere near comprehensive.

### Documentation

Documentation should be included in your source archive in the `docs/` folder. It should be clear, concise and readable. Fancy formatting is not necessary, just give us a clear idea what you did for each phase. Acceptable file formats are pdf.

Your documentation must include the following parts, which could be described as __Design__, __Extras__, __Difficulties__, and __Contribution__. Not every question or point of each part need to be addressed, just enough information to describe each portion effectively:

1. __Design__ - An overview of your design, an analysis of design alternatives you considered, and key design decisions. Be sure to document and justify all design decisions you make. Any decision accompanied by a convincing argument will be accepted. If you realize there are flaws or deficiencies in your design late in the implementation process, discuss those flaws and how you would have done things differently. Also include any changes you made to previous parts and why they were necessary. This section should aid the TA in being able to read and give feedback on the code written.
1. __Extras__ - A list of any clarifications, assumptions, or additions to the problem assigned. This include any interesting debugging techniques/logging, additional build scripts, or approved libraries used in designing the compiler. The project specifications are fairly broad and leave many of the decisions to you. This is an aspect of real software engineering. If you think major clarifications are necessary, consult the TA.
1. __Difficulties__ - A list of known problems with your project, and as much as you know about the cause. If your project fails a provided test case, but you are unable to fix the problem, describe your understanding of the problem. If you discover problems in your project in your own testing that you are unable to fix, but are not exposed by the provided test cases, describe the problem as specifically as possible and as much as you can about its cause. If this causes your project to fail hidden test cases, you may still be able to receive some credit for considering the problem. If this problem is not revealed by the hidden test cases, then you will not be penalized for it. It is to your advantage to describe any known problems with your project; of course, it is even better to fix them. Also describe any section of your project that you would like to highlight for more feedback on/had questions on.
1. __Contribution__ -A brief description of how your group divided the work. This will not affect your grade; it will be used to alert the TAs to any possible problems. (Projects 3/5 only.)

## Reference

1. [x64 wiki](https://en.wikibooks.org/wiki/X86_Assembly/X86_Instructions)
1. [x64 cheat sheet](https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf) -- lists and tables detailing registers and assembly commands
1. [x86-64 architecture guide](http://6.035.scripts.mit.edu/fa18/x86-64-architecture-guide.html) -- a walkthrough with an example, and common commands
1. [Intel x64 manual](https://software.intel.com/en-us/articles/intel-sdm)

## Assembly Examples

1. print `32` using the `printf` function in the standard C library
    ```s
    format_str_0:
        .string "%d\n"  # string constant

    .globl main
    main:
        # pre-call ritual
        pushq %rbp         # save base pointer
        movq  %rsp, %rbp   # save stack pointer

        # call function `printf`
        leaq format_str_0(%rip), %rdi  # 1st arg; load the address of str constant into %rdi
        movq $32, %rsi                 # 2nd arg; load int constant into %rsi
        call printf                    # call with the above args

        # post-call ritual
        movq %rbp, %rsp
        popq %rbp
        ret  # return to where the function was called
    ```
1. a function `calc(a, b, c, d, e)` which returns `(a*b - c/d)*e` where `c/d` discards remainders; for example `3/2 = 1`
    ```s
    calc:
        # pre-call ritual
        pushq %rbp
        movq  %rsp, %rbp

        # %rsi = %rdi * %rsi; calculate a * b
        imul %rdi, %rsi

        # %rax = %rdx / %rcx; calculate c / d
        movq %rdx, %rax  # move %rdx into %rax
        xor  %rdx, %rdx  # zero-out %rdx by xor'ing it with itself
        idiv %rcx        # %rax = %rdx:%rax / %rcx = %rax / %rcx since %rdx = 0

        # %rsi = %rsi - %rax; calculate a*b - c/d
        subq %rax, %rsi

        # %rsi = %rsi * %r8; calculate (a*b - c/d) * e
        imul %r8, %rsi
        
        # move the final value into %rax to return it
        movq %rsi, %rax

        # post-call ritual
        movq %rbp, %rsp
        popq %rbp
        ret
    
    main:
        # ...

        # calculate (4*5 - 3/2)*1
        movq $4, %rdi  # 1st arg; a=4
        movq $5, %rsi  # 2nd arg; b=5
        movq $3, %rdx  # 3rd arg; c=3
        movq $2, %rcx  # 4th arg; d=2
        movq $1, %r8   # 5th arg; e=1
        call calc # retval = 19 is now in %rax

        # ..
    ```
